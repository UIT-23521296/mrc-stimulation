# ==================================================
# Path: E:\Dai Hoc\NCKH\mrc-simulation
# Detected tech: java, javascript, rust, typescript
# ==================================================

## DIRECTORY STRUCTURE
```
mrc-simulation/
‚îú‚îÄ‚îÄ .git/
‚îú‚îÄ‚îÄ artifacts/
‚îÇ   ‚îú‚îÄ‚îÄ build-info/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ 86f3e3a56581c3075b2c7d67f0a06a36.json
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ be2fa38bc0510f8ff4f813936024fc11.json
‚îÇ   ‚îî‚îÄ‚îÄ contracts/
‚îÇ       ‚îú‚îÄ‚îÄ RelayRegistry.sol/
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ ITargetReceiver.dbg.json
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ ITargetReceiver.json
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ RelayRegistry.dbg.json
‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ RelayRegistry.json
‚îÇ       ‚îú‚îÄ‚îÄ SourceApp.sol/
‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ SourceApp.dbg.json
‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ SourceApp.json
‚îÇ       ‚îî‚îÄ‚îÄ TargetReceiver.sol/
‚îÇ           ‚îú‚îÄ‚îÄ TargetReceiver.dbg.json
‚îÇ           ‚îî‚îÄ‚îÄ TargetReceiver.json
‚îú‚îÄ‚îÄ cache/
‚îÇ   ‚îî‚îÄ‚îÄ solidity-files-cache.json
‚îú‚îÄ‚îÄ contracts/
‚îÇ   ‚îú‚îÄ‚îÄ RelayRegistry.sol
‚îÇ   ‚îú‚îÄ‚îÄ SourceApp.sol
‚îÇ   ‚îî‚îÄ‚îÄ TargetReceiver.sol
‚îú‚îÄ‚îÄ ignition/
‚îÇ   ‚îî‚îÄ‚îÄ modules/
‚îÇ       ‚îî‚îÄ‚îÄ Lock.js
‚îú‚îÄ‚îÄ node_modules/
‚îú‚îÄ‚îÄ relay-algorithms/
‚îÇ   ‚îú‚îÄ‚îÄ adaptiveProperties.js
‚îÇ   ‚îú‚îÄ‚îÄ hybridAdaptive.js
‚îÇ   ‚îú‚îÄ‚îÄ index.js
‚îÇ   ‚îú‚îÄ‚îÄ resourceBased.js
‚îÇ   ‚îú‚îÄ‚îÄ roundRobin.js
‚îÇ   ‚îî‚îÄ‚îÄ wlc.js
‚îú‚îÄ‚îÄ script/
‚îÇ   ‚îú‚îÄ‚îÄ deployments/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ destinationChain/
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ TargetReceiver.json
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ relayChain1/
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ RelayRegistry.json
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ relayChain2/
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ RelayRegistry.json
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ relayChain3/
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ RelayRegistry.json
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ sourceChain/
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ SourceApp.json
‚îÇ   ‚îú‚îÄ‚îÄ .env
‚îÇ   ‚îú‚îÄ‚îÄ deploy-dc.js
‚îÇ   ‚îú‚îÄ‚îÄ deploy-source.js
‚îÇ   ‚îú‚îÄ‚îÄ deploy.js
‚îÇ   ‚îú‚îÄ‚îÄ prover-rc2dc.js
‚îÇ   ‚îú‚îÄ‚îÄ prover-sc2rc.js
‚îÇ   ‚îú‚îÄ‚îÄ prover.js
‚îÇ   ‚îú‚îÄ‚îÄ sendCtx.js
‚îÇ   ‚îú‚îÄ‚îÄ simulation.js
‚îÇ   ‚îî‚îÄ‚îÄ start-all.bat
‚îú‚îÄ‚îÄ test/
‚îÇ   ‚îî‚îÄ‚îÄ Lock.js
‚îú‚îÄ‚îÄ .env
‚îú‚îÄ‚îÄ .gitignore
‚îú‚îÄ‚îÄ Lu·ªìng.docx
‚îú‚îÄ‚îÄ README.md
‚îú‚îÄ‚îÄ checken.js
‚îú‚îÄ‚îÄ hardhat.config.js
‚îú‚îÄ‚îÄ package-lock.json
‚îú‚îÄ‚îÄ package.json
‚îú‚îÄ‚îÄ registry-address.json
‚îî‚îÄ‚îÄ source_dump.txt
```

## FILE CONTENTS

### checken.js
```js
require("dotenv").config();
console.log("PRIVATE_KEY =", JSON.stringify(process.env.PRIVATE_KEY));

```

### hardhat.config.js
```js
require("@nomicfoundation/hardhat-toolbox");

/** @type import('hardhat/config').HardhatUserConfig */
module.exports = {
  solidity: "0.8.24",
  networks: {
    hardhat: {},
    relayChain1: {
      url: "http://127.0.0.1:8545",
      accounts: ['0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80']
    },
    relayChain2: {
      url: "http://127.0.0.1:8546",
      accounts: ['0x59c6995e998f97a5a0044966f0945389dc9e86dae88c7a8412f4603b6b78690d']
    },
    relayChain3: {
      url: "http://127.0.0.1:8547",
      accounts: ['0x5de4111afa1a4b94908f83103eb1f1706367c2e68ca870fc3fb9a804cdab365a']
    },
    sourceChain: {
      url: "http://127.0.0.1:8548",
      accounts: ['0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80']
    },
    destinationChain: {
      url: "http://127.0.0.1:8549",
      accounts: ['0x701b615bbdfb9de65240bc28bd21bbc0d996645a3dd57e7b12bc2bdf6f192c82']
    }

  }
};

```

### ignition\modules\Lock.js
```js
// This setup uses Hardhat Ignition to manage smart contract deployments.
// Learn more about it at https://hardhat.org/ignition

const { buildModule } = require("@nomicfoundation/hardhat-ignition/modules");

const JAN_1ST_2030 = 1893456000;
const ONE_GWEI = 1_000_000_000n;

module.exports = buildModule("LockModule", (m) => {
  const unlockTime = m.getParameter("unlockTime", JAN_1ST_2030);
  const lockedAmount = m.getParameter("lockedAmount", ONE_GWEI);

  const lock = m.contract("Lock", [unlockTime], {
    value: lockedAmount,
  });

  return { lock };
});

```

### relay-algorithms\adaptiveProperties.js
```js
const { ethers } = require("hardhat");

// ‚öôÔ∏è Adaptive Calculation Parameters
const ADAPTIVE_CONFIG = {
  // Security thresholds
  SECURITY_THRESHOLDS: {
    HIGH_FAILURE_RATE: 0.05,    // 5% failure rate = High security
    MEDIUM_FAILURE_RATE: 0.15,  // 15% failure rate = Medium security
    LOW_FAILURE_RATE: 0.30,     // 30% failure rate = Low security
    CONSECUTIVE_FAILURE_LIMIT: 3
  },
  
  // Performance thresholds
  PERFORMANCE_THRESHOLDS: {
    FAST_LATENCY: 200,          // < 200ms = Fast
    NORMAL_LATENCY: 500,        // < 500ms = Normal
    SLOW_LATENCY: 1000,         // > 1000ms = Slow
    HIGH_THROUGHPUT: 100,       // > 100 tx/min = High throughput
    LOW_THROUGHPUT: 10          // < 10 tx/min = Low throughput
  },
  
  // Cost thresholds
  COST_THRESHOLDS: {
    PREMIUM_GAS_PRICE: 2000000000,    // > 2 gwei = Premium
    STANDARD_GAS_PRICE: 1500000000,   // 1.5-2 gwei = Standard
    ECONOMY_GAS_PRICE: 1000000000,    // < 1 gwei = Economy
    GAS_PRICE_HISTORY_SIZE: 20
  },
  
  // Capacity thresholds
  CAPACITY_THRESHOLDS: {
    HIGH_UTILIZATION: 0.8,      // > 80% = High utilization
    MEDIUM_UTILIZATION: 0.5,    // 50-80% = Medium utilization
    LOW_UTILIZATION: 0.3,       // < 30% = Low utilization
    SAFETY_MARGIN: 0.2          // 20% safety margin
  },
  
  // Learning parameters
  LEARNING: {
    HISTORY_SIZE: 50,
    DECAY_FACTOR: 0.95,         // Weight decay for old data
    MIN_SAMPLES: 1              // Minimum samples before calculating
  }
};

// üèÜ Security Level Ranking
const SECURITY_LEVELS = {
  'High': 3,
  'Medium': 2,
  'Low': 1
};

// ‚ö° Processing Speed Ranking
const PROCESSING_SPEEDS = {
  'Fast': 3,
  'Normal': 2,
  'Slow': 1
};

// ÔøΩÔøΩ Cost Tier Ranking
const COST_TIERS = {
  'Premium': 3,
  'Standard': 2,
  'Economy': 1
};

// 1. H√†m t√≠nh to√°n Security Level adaptive
function calculateAdaptiveSecurityLevel(relay) {
  const metrics = relay.adaptiveMetrics;
  
  // T√≠nh failure rate
  const totalAttempts = metrics.successHistory.length + metrics.failureHistory.length;
  if (totalAttempts < ADAPTIVE_CONFIG.LEARNING.MIN_SAMPLES) {
    return 'Medium'; // Default khi ch∆∞a ƒë·ªß data
  }
  
  metrics.failureRate = metrics.failureHistory.length / totalAttempts;
  
  // T√≠nh security score d·ª±a tr√™n nhi·ªÅu y·∫øu t·ªë
  let securityScore = 1.0;
  
  // Factor 1: Failure rate
  if (metrics.failureRate <= ADAPTIVE_CONFIG.SECURITY_THRESHOLDS.HIGH_FAILURE_RATE) {
    securityScore *= 1.0;
  } else if (metrics.failureRate <= ADAPTIVE_CONFIG.SECURITY_THRESHOLDS.MEDIUM_FAILURE_RATE) {
    securityScore *= 0.8;
  } else {
    securityScore *= 0.5;
  }
  
  // Factor 2: Consecutive failures
  if (metrics.consecutiveFailures >= ADAPTIVE_CONFIG.SECURITY_THRESHOLDS.CONSECUTIVE_FAILURE_LIMIT) {
    securityScore *= 0.3;
  }
  
  // Factor 3: Recent failures (failures trong 1 gi·ªù qua)
  const oneHourAgo = Date.now() - 3600000;
  const recentFailures = metrics.failureHistory.filter(time => time > oneHourAgo).length;
  if (recentFailures > 0) {
    securityScore *= (1 - recentFailures * 0.1);
  }
  
  metrics.securityScore = Math.max(0.1, Math.min(1.0, securityScore));
  
  // Map score to security level
  if (metrics.securityScore >= 0.8) return 'High';
  if (metrics.securityScore >= 0.5) return 'Medium';
  return 'Low';
}

// 2. H√†m t√≠nh to√°n Processing Speed adaptive
function calculateAdaptiveProcessingSpeed(relay) {
  const metrics = relay.adaptiveMetrics;
  
  if (metrics.latencyHistory.length < ADAPTIVE_CONFIG.LEARNING.MIN_SAMPLES) {
    return 'Normal'; // Default
  }
  
  // T√≠nh average latency
  metrics.avgLatency = metrics.latencyHistory.reduce((a, b) => a + b, 0) / metrics.latencyHistory.length;
  
  // T√≠nh latency variance
  const variance = metrics.latencyHistory.reduce((sum, latency) => {
    return sum + Math.pow(latency - metrics.avgLatency, 2);
  }, 0) / metrics.latencyHistory.length;
  metrics.latencyVariance = Math.sqrt(variance);
  
  // T√≠nh throughput (transactions per minute)
  const recentSuccesses = metrics.successHistory.filter(time => 
    time > Date.now() - 60000 // 1 ph√∫t qua
  ).length;
  metrics.throughput = recentSuccesses;
  
  // T√≠nh performance score
  let performanceScore = 1.0;
  
  // Factor 1: Average latency
  if (metrics.avgLatency <= ADAPTIVE_CONFIG.PERFORMANCE_THRESHOLDS.FAST_LATENCY) {
    performanceScore *= 1.0;
  } else if (metrics.avgLatency <= ADAPTIVE_CONFIG.PERFORMANCE_THRESHOLDS.NORMAL_LATENCY) {
    performanceScore *= 0.8;
  } else {
    performanceScore *= 0.5;
  }
  
  // Factor 2: Latency consistency (variance th·∫•p = t·ªët)
  const normalizedVariance = Math.min(metrics.latencyVariance / metrics.avgLatency, 1.0);
  performanceScore *= (1 - normalizedVariance * 0.3);
  
  // Factor 3: Throughput
  if (metrics.throughput >= ADAPTIVE_CONFIG.PERFORMANCE_THRESHOLDS.HIGH_THROUGHPUT) {
    performanceScore *= 1.2;
  } else if (metrics.throughput <= ADAPTIVE_CONFIG.PERFORMANCE_THRESHOLDS.LOW_THROUGHPUT) {
    performanceScore *= 0.7;
  }
  
  metrics.performanceScore = Math.max(0.1, Math.min(1.0, performanceScore));
  
  // Map score to processing speed
  if (metrics.performanceScore >= 0.8) return 'Fast';
  if (metrics.performanceScore >= 0.5) return 'Normal';
  return 'Slow';
}

// 3. H√†m t√≠nh to√°n Cost Tier adaptive
function calculateAdaptiveCostTier(relay) {
  const metrics = relay.adaptiveMetrics;
  
  if (metrics.gasPriceHistory.length < ADAPTIVE_CONFIG.LEARNING.MIN_SAMPLES) {
    return 'Standard'; // Default
  }
  
  // T√≠nh average gas price
  metrics.avgGasPrice = metrics.gasPriceHistory.reduce((a, b) => a + b, 0) / metrics.gasPriceHistory.length;
  
  // T√≠nh gas price trend (tƒÉng/gi·∫£m)
  if (metrics.gasPriceHistory.length >= 2) {
    const recent = metrics.gasPriceHistory.slice(-5);
    const older = metrics.gasPriceHistory.slice(-10, -5);
    const recentAvg = recent.reduce((a, b) => a + b, 0) / recent.length;
    const olderAvg = older.reduce((a, b) => a + b, 0) / older.length;
    metrics.gasPriceTrend = (recentAvg - olderAvg) / olderAvg;
  }
  
  // T√≠nh cost efficiency
  const normalizedGasPrice = Math.min(metrics.avgGasPrice / ADAPTIVE_CONFIG.COST_THRESHOLDS.PREMIUM_GAS_PRICE, 1.0);
  metrics.costEfficiency = 1 - normalizedGasPrice;
  
  // T√≠nh cost score
  let costScore = 1.0;
  
  // Factor 1: Average gas price
  if (metrics.avgGasPrice <= ADAPTIVE_CONFIG.COST_THRESHOLDS.ECONOMY_GAS_PRICE) {
    costScore *= 1.0;
  } else if (metrics.avgGasPrice <= ADAPTIVE_CONFIG.COST_THRESHOLDS.STANDARD_GAS_PRICE) {
    costScore *= 0.8;
  } else {
    costScore *= 0.5;
  }
  
  // Factor 2: Gas price trend (gi·∫£m = t·ªët)
  if (metrics.gasPriceTrend < -0.1) { // Gi·∫£m > 10%
    costScore *= 1.1;
  } else if (metrics.gasPriceTrend > 0.1) { // TƒÉng > 10%
    costScore *= 0.9;
  }
  
  metrics.costScore = Math.max(0.1, Math.min(1.0, costScore));
  
  // Map score to cost tier
  if (metrics.costScore >= 0.8) return 'Economy';
  if (metrics.costScore >= 0.5) return 'Standard';
  return 'Premium';
}

// 4. H√†m t√≠nh to√°n Max Gas Limit adaptive
function calculateAdaptiveMaxGasLimit(relay) {
  const metrics = relay.adaptiveMetrics;
  
  // Base gas limit
  let baseGasLimit = 20000000;
  
  // T√≠nh capacity utilization
  if (metrics.maxObservedGas > 0) {
    metrics.capacityUtilization = metrics.currentGasUsage / metrics.maxObservedGas;
  }
  
  // T√≠nh capacity score
  let capacityScore = 1.0;
  
  // Factor 1: Current utilization
  if (metrics.capacityUtilization <= ADAPTIVE_CONFIG.CAPACITY_THRESHOLDS.LOW_UTILIZATION) {
    capacityScore *= 1.0; // C√≥ th·ªÉ tƒÉng gas limit
  } else if (metrics.capacityUtilization <= ADAPTIVE_CONFIG.CAPACITY_THRESHOLDS.MEDIUM_UTILIZATION) {
    capacityScore *= 0.8; // Gi·ªØ nguy√™n
  } else {
    capacityScore *= 0.6; // Gi·∫£m gas limit
  }
  
  // Factor 2: Historical max gas usage
  if (metrics.maxObservedGas > 0) {
    const safetyMargin = 1 - ADAPTIVE_CONFIG.CAPACITY_THRESHOLDS.SAFETY_MARGIN;
    baseGasLimit = Math.max(baseGasLimit, metrics.maxObservedGas / safetyMargin);
  }
  
  // Factor 3: Performance impact
  if (metrics.performanceScore < 0.5) {
    baseGasLimit *= 0.8; // Gi·∫£m gas limit n·∫øu performance k√©m
  }
  
  metrics.capacityScore = Math.max(0.1, Math.min(1.0, capacityScore));
  
  // ƒê·∫£m b·∫£o gas limit trong kho·∫£ng h·ª£p l√Ω
  return Math.max(1000000, Math.min(50000000, Math.floor(baseGasLimit)));
}

// 5. H√†m c·∫≠p nh·∫≠t adaptive properties
async function updateAdaptiveProperties(relays) {
  for (const chain of relays) {
    if (!chain.healthy) continue;
    
    try {
      // C·∫≠p nh·∫≠t historical data
      updateHistoricalData(chain);
      
      // T√≠nh to√°n adaptive properties
      chain.capabilities.securityLevel = calculateAdaptiveSecurityLevel(chain);
      chain.capabilities.processingSpeed = calculateAdaptiveProcessingSpeed(chain);
      chain.capabilities.costTier = calculateAdaptiveCostTier(chain);
      chain.capabilities.maxGasLimit = calculateAdaptiveMaxGasLimit(chain);
      
      console.log(`üîÑ ${chain.name} Adaptive Properties:`);
      console.log(`   Security: ${chain.capabilities.securityLevel} (Score: ${chain.adaptiveMetrics.securityScore.toFixed(2)})`);
      console.log(`   Speed: ${chain.capabilities.processingSpeed} (Score: ${chain.adaptiveMetrics.performanceScore.toFixed(2)})`);
      console.log(`   Cost: ${chain.capabilities.costTier} (Score: ${chain.adaptiveMetrics.costScore.toFixed(2)})`);
      console.log(`   Max Gas: ${chain.capabilities.maxGasLimit.toLocaleString()}`);
      
    } catch (error) {
      console.error(`Error updating adaptive properties for ${chain.name}:`, error.message);
    }
  }
}

// 6. H√†m c·∫≠p nh·∫≠t historical data
function updateHistoricalData(chain) {
  const metrics = chain.adaptiveMetrics;
  
  // C·∫≠p nh·∫≠t latency history
  if (chain.latency > 0) {
    metrics.latencyHistory.push(chain.latency);
    if (metrics.latencyHistory.length > ADAPTIVE_CONFIG.LEARNING.HISTORY_SIZE) {
      metrics.latencyHistory.shift();
    }
  }
  
  // C·∫≠p nh·∫≠t gas price history
  if (chain.gasPrice > 0) {
    metrics.gasPriceHistory.push(chain.gasPrice);
    if (metrics.gasPriceHistory.length > ADAPTIVE_CONFIG.COST_THRESHOLDS.GAS_PRICE_HISTORY_SIZE) {
      metrics.gasPriceHistory.shift();
    }
  }
  
  // C·∫≠p nh·∫≠t max observed gas
  if (chain.load > 0) {
    const estimatedGasUsage = chain.load * 100000; // ∆Ø·ªõc t√≠nh gas usage
    metrics.maxObservedGas = Math.max(metrics.maxObservedGas, estimatedGasUsage);
    metrics.currentGasUsage = estimatedGasUsage;
  }
}

// 7. H√†m track transaction results
function trackTransactionResult(relay, success, gasUsed = 0) {
  const metrics = relay.adaptiveMetrics;
  const currentTime = Date.now();
  
  if (success) {
    metrics.successHistory.push(currentTime);
    metrics.consecutiveFailures = 0;
  } else {
    metrics.failureHistory.push(currentTime);
    metrics.consecutiveFailures++;
    metrics.lastFailureTime = currentTime;
  }
  
  // Clean old history (gi·ªØ 24 gi·ªù)
  const oneDayAgo = currentTime - 86400000;
  metrics.successHistory = metrics.successHistory.filter(time => time > oneDayAgo);
  metrics.failureHistory = metrics.failureHistory.filter(time => time > oneDayAgo);
  
  // C·∫≠p nh·∫≠t max observed gas
  if (gasUsed > 0) {
    metrics.maxObservedGas = Math.max(metrics.maxObservedGas, gasUsed);
  }
}

function computeWeight(relay) {
  const perf = relay.adaptiveMetrics.performanceScore || 0.8;
  const cost = relay.adaptiveMetrics.costEfficiency || 0.8;
  const reliab = 1.0 - Math.min(relay.adaptiveMetrics.failureRate || 0.1, 1.0);
  const latency = relay.adaptiveMetrics.avgLatency || 300;

  // ‚öñÔ∏è Thang ƒëi·ªÉm latency: latency th·∫•p ‚Üí ƒëi·ªÉm cao (nh∆∞ng b√≥p gi·ªõi h·∫°n l·∫°i)
  const latencyScore = Math.max(0.1, Math.min(1.0, 150 / latency));

  // üß† T·ªïng ƒëi·ªÉm: b·∫°n c√≥ th·ªÉ ƒëi·ªÅu ch·ªânh tr·ªçng s·ªë theo √Ω ƒë·ªì
  const rawScore = (
    perf * 0.45 +        // hi·ªáu nƒÉng: ∆∞u ti√™n ch√≠nh
    cost * 0.2 +         // chi ph√≠
    reliab * 0.2 +       // ƒë·ªô tin c·∫≠y
    latencyScore * 0.15  // ƒë·ªô tr·ªÖ
  );

  // üéØ Scale v·ªÅ tr·ªçng s·ªë 1‚Äì5
  const scaled = Math.round(rawScore * 5);
  const weight = Math.min(5, Math.max(1, scaled));

  relay.weight = weight;

  // üß™ Debug log n·∫øu c·∫ßn
  // console.log(`${relay.name}: perf=${perf.toFixed(2)}, cost=${cost.toFixed(2)}, reliab=${reliab.toFixed(2)}, latencyScore=${latencyScore.toFixed(2)} ‚Üí weight=${weight}`);

  return weight;
}

module.exports = {
  updateAdaptiveProperties,
  trackTransactionResult,
  updateHistoricalData,
  calculateAdaptiveSecurityLevel,
  calculateAdaptiveProcessingSpeed,
  calculateAdaptiveCostTier,
  calculateAdaptiveMaxGasLimit,
  ADAPTIVE_CONFIG,
  computeWeight
};


```

### relay-algorithms\hybridAdaptive.js
```js
const { ethers } = require("hardhat");
const { selectRelay_WLC } = require('./wlc'); 

// üèÜ Ranking mappings
const SECURITY_LEVELS = { High: 3, Medium: 2, Low: 1 };
const PROCESSING_SPEEDS = { Fast: 3, Normal: 2, Slow: 1 };
const COST_TIERS = { Premium: 3, Standard: 2, Economy: 1 };

// ‚öôÔ∏è Tr·ªçng s·ªë Hybrid Adaptive
const HYBRID_WEIGHTS = {
    LOAD: 0.25,
    LATENCY: 0.20,
    SUCCESS_RATE: 0.25,
    GAS_PRICE: 0.15,
    CONGESTION: 0.15,
    RELIABILITY: 0.10
};

// üéØ B·ªô l·ªçc theo ch·ªß ƒë·ªÅ giao d·ªãch
function filterRelaysByTopic(transactionType, requirements, relays) {
    const req = requirements[transactionType];
    if (!req) throw new Error(`‚ùå Unknown transaction type: ${transactionType}`);

    const eligibleRelays = relays.filter(relay => {
        if (!relay.healthy) return false;

        const cap = relay.capabilities;
        const securityOK = SECURITY_LEVELS[cap.securityLevel] >= SECURITY_LEVELS[req.minSecurityLevel];
        const speedOK = PROCESSING_SPEEDS[cap.processingSpeed] >= PROCESSING_SPEEDS[req.minProcessingSpeed];
        const costOK = COST_TIERS[cap.costTier] <= COST_TIERS[req.maxCostTier];
        const tokenOK = req.requiredTokens.some(t => cap.supportedTokens.includes(t));
        const typeOK = req.requiredTypes.some(t => cap.transactionTypes.includes(t));
        const gasOK = cap.maxGasLimit >= req.minGasLimit;

        return securityOK && speedOK && costOK && tokenOK && typeOK && gasOK;
    });

    console.log(`üîç Topic-based filtering for ${transactionType}: ${eligibleRelays.length}/${relays.length} eligible`);
    return eligibleRelays;
}

// üß† T√≠nh ƒëi·ªÉm v·ªõi normalize ƒë·ªông
function computeAdvancedResourceScore(relay, allRelays, transactionType, requirements, calculateSuccessRate) {
    const req = requirements[transactionType];

    // Normalize ƒë·ªông
    const maxLoad = Math.max(...allRelays.map(r => r.load), 1);
    const maxLatency = Math.max(...allRelays.map(r => r.latency), 1);
    const maxGas = Math.max(...allRelays.map(r => r.gasPrice), 1);
    const maxCongestion = Math.max(...allRelays.map(r => r.networkCongestion), 1);

    const normalizedLoad = relay.load / maxLoad;
    const normalizedLatency = relay.latency / maxLatency;
    const normalizedGasPrice = relay.gasPrice / maxGas;
    const normalizedCongestion = relay.networkCongestion / maxCongestion;
    const successRate = calculateSuccessRate(relay);
    const reliability = relay.performance.reliabilityScore || 1.0;

    // ∆Øu ti√™n theo priority
    const priorityMultiplier = {
        High: 1.5,
        Medium: 1.2,
        Low: 1.0
    }[req.priority] || 1.0;

    const score =
        HYBRID_WEIGHTS.LOAD * (1 - normalizedLoad) +
        HYBRID_WEIGHTS.LATENCY * (1 - normalizedLatency) +
        HYBRID_WEIGHTS.SUCCESS_RATE * successRate +
        HYBRID_WEIGHTS.GAS_PRICE * (1 - normalizedGasPrice) +
        HYBRID_WEIGHTS.CONGESTION * (1 - normalizedCongestion) +
        HYBRID_WEIGHTS.RELIABILITY * reliability;

    return score * priorityMultiplier;
}

// üèÜ H√†m ch·ªçn relay ch√≠nh
function selectRelay_HybridAdaptive(relays, transactionType, requirements, calculateSuccessRate) {
    console.log(`\nüéØ Hybrid Adaptive Selection for ${transactionType}`);

    const eligible = filterRelaysByTopic(transactionType, requirements, relays);
    if (eligible.length === 0) 
      return null;

    let bestRelay = null;
    let bestScore = -Infinity;

    console.log(`‚öñÔ∏è  Scoring ${eligible.length} eligible relays:`);

    for (const relay of eligible) {
        const score = computeAdvancedResourceScore(relay, eligible, transactionType, requirements, calculateSuccessRate);
        const successRate = calculateSuccessRate(relay);

        console.log(`   - ${relay.name}:`);
        console.log(`     Load=${relay.load}, Latency=${relay.latency}ms, Success=${(successRate * 100).toFixed(1)}%`);
        console.log(`     Gas=${ethers.formatUnits(relay.gasPrice, 'gwei')} gwei, Congestion=${(relay.networkCongestion * 100).toFixed(1)}%`);
        console.log(`     Score=${score.toFixed(3)}`);

        if (score > bestScore) {
            bestScore = score;
            bestRelay = relay;
        }
    }

    console.log(`üèÜ Selected: ${bestRelay.name} (score=${bestScore.toFixed(3)})`);
    return bestRelay;
}

// üìà C·∫≠p nh·∫≠t hi·ªáu su·∫•t
async function updatePerformanceMetrics(relays, calculateSuccessRate) {
    for (const r of relays) {
        if (!r.healthy) continue;

        try {
            if (r.historicalLatency.length > 0) {
                const avg = r.historicalLatency.reduce((a, b) => a + b, 0) / r.historicalLatency.length;
                r.performance.avgProcessingTime = avg;
            }

            const successRate = calculateSuccessRate(r);
            r.performance.reliabilityScore = successRate;

            const normalizedGas = Math.min(r.gasPrice / 50000000000, 1.0);
            r.performance.costEfficiency = 1 - normalizedGas;
        } catch (e) {
            console.error(`‚ö†Ô∏è Error updating performance for ${r.name}: ${e.message}`);
        }
    }
}

module.exports = {
    selectRelay_HybridAdaptive,
    filterRelaysByTopic,
    computeAdvancedResourceScore,
    updatePerformanceMetrics
};

```

### relay-algorithms\index.js
```js
module.exports = {
    ...require('./roundRobin'),
    ...require('./wlc'),
    ...require('./resourceBased'),
    ...require('./hybridAdaptive'),
    ...require('./adaptiveProperties'),
    computeWeight: require('./adaptiveProperties').computeWeight
};
  
```

### relay-algorithms\resourceBased.js
```js
const { ethers } = require("hardhat");
const MAX_HISTORICAL_LATENCY = 10; // S·ªë l∆∞·ª£ng latency history ƒë·ªÉ l∆∞u

// ‚öôÔ∏è Tham s·ªë Resource-Based Selection
const RESOURCE_WEIGHTS = {
    LOAD: 0.25,           // Tr·ªçng s·ªë cho t·∫£i
    LATENCY: 0.20,        // Tr·ªçng s·ªë cho ƒë·ªô tr·ªÖ
    SUCCESS_RATE: 0.25,   // Tr·ªçng s·ªë cho t·ª∑ l·ªá th√†nh c√¥ng
    GAS_PRICE: 0.15,      // Tr·ªçng s·ªë cho gi√° gas
    CONGESTION: 0.15      // Tr·ªçng s·ªë cho t·∫Øc ngh·∫Ωn m·∫°ng
};

// ================= Resource-Based Selection =================
function calculateSuccessRate(relay) {
    if (relay.totalRequests === 0) return 1.0;
    return relay.successCount / relay.totalRequests;
}

async function updateResourceInfo(relays, maxLatencyHistory = 10) {
    for (const chain of relays) {
        if (!chain.healthy) continue;
        
        try {
            // C·∫≠p nh·∫≠t gas price
            const feeData = await chain.provider.getFeeData();
            console.log(`[${chain.name}] feeData =`, feeData);
            chain.gasPrice = Number(feeData.gasPrice);
            
            // C·∫≠p nh·∫≠t block time
            const currentBlock = await chain.provider.getBlockNumber();
            const block = await chain.provider.getBlock(currentBlock);
            let blockTime = 0;
            if (currentBlock > 0) {
                const prevBlock = await chain.provider.getBlock(currentBlock - 1);
                blockTime = block.timestamp - prevBlock.timestamp;
            }
            chain.blockTime = blockTime;
            
            // C·∫≠p nh·∫≠t network congestion (d·ª±a tr√™n gas price)
            chain.networkCongestion = Math.min(chain.gasPrice / 20000000000, 1.0); // Normalize
            
            // C·∫≠p nh·∫≠t historical latency
            chain.historicalLatency.push(chain.latency);
            if (chain.historicalLatency.length > MAX_HISTORICAL_LATENCY) {
                chain.historicalLatency.shift();
            }
        
            // C·∫≠p nh·∫≠t min/max latency
            chain.maxLatency = Math.max(chain.maxLatency, chain.latency);
            chain.minLatency = Math.min(chain.minLatency, chain.latency);
        
        } catch (error) {
            console.error(`Error updating resource info for ${chain.name}:`, error.message);
        }
    }
}
  
function computeResourceScore(relay, allRelays) {
    // T√¨m gi√° tr·ªã max th·ª±c t·∫ø t·ª´ t·∫•t c·∫£ relay
    const maxLoad = Math.max(...allRelays.map(r => r.load), 1);
    const maxLatency = Math.max(...allRelays.map(r => r.latency), 1);
    const maxGasPrice = Math.max(...allRelays.map(r => r.gasPrice), 1);
    const maxCongestion = Math.max(...allRelays.map(r => r.networkCongestion), 1);

    // Normalize d·ª±a tr√™n max th·ª±c t·∫ø (tr√°nh chia 0)
    const normalizedLoad = relay.load / maxLoad;
    const normalizedLatency = relay.latency / maxLatency;
    const normalizedGasPrice = relay.gasPrice / maxGasPrice;
    const normalizedCongestion = relay.networkCongestion / maxCongestion;
    const successRate = calculateSuccessRate(relay); // gi·ªØ nguy√™n

    // T√≠nh ƒëi·ªÉm t·ªïng h·ª£p
    const score = 
        RESOURCE_WEIGHTS.LOAD * (1 - normalizedLoad) +
        RESOURCE_WEIGHTS.LATENCY * (1 - normalizedLatency) +
        RESOURCE_WEIGHTS.SUCCESS_RATE * successRate +
        RESOURCE_WEIGHTS.GAS_PRICE * (1 - normalizedGasPrice) +
        RESOURCE_WEIGHTS.CONGESTION * (1 - normalizedCongestion);

    return score;
}

  
function selectRelay_ResourceBased(relays) {
    const healthy = relays.filter(r => r.healthy);
    if (healthy.length === 0) throw new Error("‚ùå No healthy relay available.");

    let bestRelay = null;
    let bestScore = -1;

    console.log("üîç Resource-Based Selection Analysis:");

    for (const relay of healthy) {
        const score = computeResourceScore(relay, healthy);
        const successRate = calculateSuccessRate(relay);
        
        console.log(`   - ${relay.name}:`);
        console.log(`     Load: ${relay.load} | Latency: ${relay.latency}ms | Success Rate: ${(successRate * 100).toFixed(1)}%`);
        console.log(`     Gas Price: ${ethers.formatUnits(relay.gasPrice, 'gwei')} gwei | Congestion: ${(relay.networkCongestion * 100).toFixed(1)}%`);
        console.log(`     Resource Score: ${score.toFixed(3)}`);
        
        if (score > bestScore) {
            bestScore = score;
            bestRelay = relay;
        }
    }

    return bestRelay;
}


module.exports = {
    selectRelay_ResourceBased,
    calculateSuccessRate,
    updateResourceInfo,
    computeResourceScore
};
```

### relay-algorithms\roundRobin.js
```js
let wrrIndex = 0;
let expandedList = [];

function expandRelaysByWeight(relays) {
  const list = [];
  for (const r of relays) {
    if (!r.healthy) continue;
    const w = r.weight || 1;
    for (let i = 0; i < w; i++) list.push(r);
  }
  return list;
}

function selectRelay_WeightedRoundRobin(relays) {
  expandedList = expandRelaysByWeight(relays);
  if (!expandedList.length) throw new Error("‚ùå No healthy relay available.");
  
  const selected = expandedList[wrrIndex % expandedList.length];
  wrrIndex = (wrrIndex + 1) % expandedList.length;
  return selected;
}

module.exports = { selectRelay_WeightedRoundRobin };

```

### relay-algorithms\wlc.js
```js
const { computeWeight } = require('./adaptiveProperties');

// ‚öôÔ∏è Tham s·ªë ƒëi·ªÅu ch·ªânh thu·∫≠t to√°n
const BETA = 0.01; // T·∫ßm ·∫£nh h∆∞·ªüng c·ªßa latency

// ‚úÖ H√†m ch·ªçn relay theo Weighted Least Connections
function selectRelay_WLC(relays) {
    const healthy = relays.filter(r => r.healthy);
    if (healthy.length === 0) throw new Error("‚ùå No healthy relay available.");

    let bestRelay = null;
    let bestScore = Infinity;

    for (const relay of healthy) {
        const weight = computeWeight(relay) || 1; // tr√°nh chia 0
        const score = (relay.load / weight) + BETA * relay.latency;

        if (score < bestScore) {
            bestScore = score;
            bestRelay = relay;
        }

        console.log(`   - ${relay.name}: Load=${relay.load}, Weight=${weight}, Latency=${relay.latency}ms, Score=${score.toFixed(3)}`);
    }

    if (!bestRelay) throw new Error("‚ùå No suitable relay selected by WLC.");

    return bestRelay;
}

// üõ∞Ô∏è H√†m ƒëo ƒë·ªô tr·ªÖ th·ª±c t·∫ø gi·ªØa app v√† c√°c relay
async function updateLatencies(relays) {
    for (const chain of relays) {
        const start = Date.now();
        try {
            await chain.provider.getBlockNumber();
            chain.latency = Date.now() - start;
            chain.healthy = true;
        } catch {
            chain.latency = Infinity;
            chain.healthy = false;
        }
    }
}

module.exports = { selectRelay_WLC, updateLatencies };

```

### script\deploy-dc.js
```js
async function main() {
  const TargetReceiver = await ethers.getContractFactory("TargetReceiver");
  const receiver = await TargetReceiver.deploy();
  await receiver.waitForDeployment();

    const fs = require("fs");
    const path = "./deployments/destinationChain";
    fs.mkdirSync(path, { recursive: true });
    fs.writeFileSync(
    `${path}/TargetReceiver.json`,
    JSON.stringify({ address: await receiver.getAddress() }, null, 2)
    );

  console.log("‚úÖ TargetReceiver deployed at:", await receiver.getAddress());
}

main().catch((error) => {
  console.error(error);
  process.exitCode = 1;
});

```

### script\deploy-source.js
```js
const hre = require("hardhat");

async function main() {
  const SourceApp = await hre.ethers.getContractFactory("SourceApp");
  const app = await SourceApp.deploy();

  await app.waitForDeployment();
    const fs = require("fs");
    const path = "./deployments/sourceChain";
    fs.mkdirSync(path, { recursive: true });
    fs.writeFileSync(
      `${path}/SourceApp.json`,
      JSON.stringify({ address: await app.getAddress() }, null, 2)
  );
  console.log(`‚úÖ SourceApp deployed at ${await app.getAddress()}`);
  

}

main().catch((error) => {
  console.error(error);
  process.exitCode = 1;
});

```

### script\deploy.js
```js
const hre = require("hardhat");
const fs = require("fs");

async function main() {
  const [deployer] = await hre.ethers.getSigners();
  console.log("Deploying contracts with the account:", deployer.address);

  const relayRegistry = await hre.ethers.deployContract("RelayRegistry");
  await relayRegistry.waitForDeployment();

  const address = await relayRegistry.getAddress();
  console.log(`RelayRegistry deployed to: ${address}`);

  // Ghi ƒë√∫ng v√†o th∆∞ m·ª•c theo t√™n m·∫°ng
  const networkName = hre.network.name;
  const path = `./deployments/${networkName}`;
  fs.mkdirSync(path, { recursive: true });
  fs.writeFileSync(`${path}/RelayRegistry.json`, JSON.stringify({ address }, null, 2));
}

main().catch((error) => {
  console.error(error);
  process.exitCode = 1;
});

```

### script\prover-rc2dc.js
```js
// prover-rc2dc.js
require("dotenv").config();
console.log("PRIVATE_KEY loaded:", process.env.PRIVATE_KEY);

const { ethers } = require("ethers");
const { generateProof } = require("./prover");
const RelayRegistryABI = require("../artifacts/contracts/RelayRegistry.sol/RelayRegistry.json").abi;
const TargetReceiverABI = require("../artifacts/contracts/TargetReceiver.sol/TargetReceiver.json").abi;
const registryAddresses = {
  8545: require("./deployments/relayChain1/RelayRegistry.json").address,
  8546: require("./deployments/relayChain2/RelayRegistry.json").address,
  8547: require("./deployments/relayChain3/RelayRegistry.json").address,
};

const targetReceiverAddress = require("./deployments/destinationChain/TargetReceiver.json").address;

const RC_PORTS = [8545, 8546, 8547];
const dcProvider = new ethers.JsonRpcProvider("http://127.0.0.1:8549");
const dcSigner = new ethers.Wallet(process.env.PRIVATE_KEY, dcProvider);
const receiver = new ethers.Contract(targetReceiverAddress, TargetReceiverABI, dcSigner);

async function main() {
  console.log("üîç Listening for RelayedFromSource events from all RCs...");

  for (const port of RC_PORTS) {
    const rcProvider = new ethers.JsonRpcProvider(`http://127.0.0.1:${port}`);
    const registryAddr = registryAddresses[port];
    const relaySigner = new ethers.Wallet(process.env.PRIVATE_KEY, rcProvider);
    const registry = new ethers.Contract(registryAddr, RelayRegistryABI, relaySigner);


    registry.on("RelayedFromSource", async (from, target, data, proofHash, event) => {
      console.log(`\nüì¶ Event from RC[${port}] to DC: target=${target}`);

      const ctx = {
        source: from,
        target,
        value: 0,
        nonce: event.logIndex + port // tr√°nh tr√πng nonce gi·ªØa c√°c RC
      };

      const proof = await generateProof(ctx, "RC2DC");

      try {
        const tx = await receiver.receiveRelay(from, data, proof.proofHash);
        await tx.wait();
        console.log(`‚úÖ Relayed from RC[${port}] ‚Üí DC: tx=${tx.hash}`);
      } catch (e) {
        console.error(`‚ùå Failed from RC[${port}]:`, e.message);
      }
    });
  }
}

main();
```

### script\prover-sc2rc.js
```js
// prover-sc2rc.js
require("dotenv").config();
console.log("PRIVATE_KEY loaded:", process.env.PRIVATE_KEY);

const { ethers } = require("ethers");
const { generateProof } = require("./prover");
const {
  selectRelay_HybridAdaptive,
  updateLatencies,
  updateResourceInfo,
  updatePerformanceMetrics,
  updateAdaptiveProperties,
  calculateSuccessRate,
  computeWeight
} = require("../relay-algorithms");

const SourceAppABI = require("../artifacts/contracts/SourceApp.sol/SourceApp.json").abi;
const RelayRegistryABI = require("../artifacts/contracts/RelayRegistry.sol/RelayRegistry.json").abi;
const registryAddresses = {
  RelayChain1: require("./deployments/relayChain1/RelayRegistry.json").address,
  RelayChain2: require("./deployments/relayChain2/RelayRegistry.json").address,
  RelayChain3: require("./deployments/relayChain3/RelayRegistry.json").address
};

const sourceAppAddress = require("./deployments/sourceChain/SourceApp.json").address;

const sourceProvider = new ethers.JsonRpcProvider("http://127.0.0.1:8548"); // SC
const signer = new ethers.Wallet(process.env.PRIVATE_KEY, sourceProvider);
const sourceApp = new ethers.Contract(sourceAppAddress, SourceAppABI, sourceProvider);

const RELAY_CHAINS = [
  {
    name: "RelayChain1",
    url: "http://127.0.0.1:8545",
    provider: new ethers.JsonRpcProvider("http://127.0.0.1:8545"),
    healthy: true,
    load: 0,
    latency: 0,
    successCount: 0,
    totalRequests: 0,
    gasPrice: 0,
    blockTime: 0,
    networkCongestion: 0,
    historicalLatency: [],
    maxLatency: 0,
    minLatency: Infinity,
    capabilities: {
      transactionTypes: ["DeFi", "NFT"],
      chainTypes: ["EVM"],
      supportedTokens: ["ETH", "USDC"],
      securityLevel: "High",
      processingSpeed: "Fast",
      costTier: "Premium",
      maxGasLimit: 30000000
    },
    adaptiveMetrics: defaultAdaptiveMetrics(),
    performance: defaultPerformance()
  },
  {
    name: "RelayChain2",
    url: "http://127.0.0.1:8546",
    provider: new ethers.JsonRpcProvider("http://127.0.0.1:8546"),
    healthy: true,
    load: 0,
    latency: 0,
    successCount: 0,
    totalRequests: 0,
    gasPrice: 0,
    blockTime: 0,
    networkCongestion: 0,
    historicalLatency: [],
    maxLatency: 0,
    minLatency: Infinity,
    capabilities: {
      transactionTypes: ["General", "Gaming"],
      chainTypes: ["EVM", "Layer2"],
      supportedTokens: ["ETH", "USDC", "DAI"],
      securityLevel: "Medium",
      processingSpeed: "Normal",
      costTier: "Standard",
      maxGasLimit: 20000000
    },
    adaptiveMetrics: defaultAdaptiveMetrics(),
    performance: defaultPerformance()
  },
  {
    name: "RelayChain3",
    url: "http://127.0.0.1:8547",
    provider: new ethers.JsonRpcProvider("http://127.0.0.1:8547"),
    healthy: true,
    load: 0,
    latency: 0,
    successCount: 0,
    totalRequests: 0,
    gasPrice: 0,
    blockTime: 0,
    networkCongestion: 0,
    historicalLatency: [],
    maxLatency: 0,
    minLatency: Infinity,
    capabilities: {
      transactionTypes: ["Gaming", "General"],
      chainTypes: ["EVM"],
      supportedTokens: ["ETH"],
      securityLevel: "Low",
      processingSpeed: "Slow",
      costTier: "Economy",
      maxGasLimit: 15000000
    },
    adaptiveMetrics: defaultAdaptiveMetrics(),
    performance: defaultPerformance()
  }
];

function defaultAdaptiveMetrics() {
  return {
    failureRate: 0,
    consecutiveFailures: 0,
    lastFailureTime: 0,
    securityScore: 1.0,
    avgLatency: 0,
    latencyVariance: 0,
    throughput: 0,
    performanceScore: 1.0,
    avgGasPrice: 0,
    gasPriceTrend: 0,
    costEfficiency: 1.0,
    costScore: 1.0,
    currentGasUsage: 0,
    maxObservedGas: 0,
    capacityUtilization: 0,
    capacityScore: 1.0,
    latencyHistory: [],
    gasPriceHistory: [],
    failureHistory: [],
    successHistory: []
  };
}

function defaultPerformance() {
  return {
    avgProcessingTime: 0,
    reliabilityScore: 1.0,
    costEfficiency: 1.0
  };
}

async function main() {
  console.log("üîç Listening for ContextSent events from SourceApp...");

  sourceApp.on("ContextSent", async (to, data, nonce, event) => {
    console.log(`\nüì¶ New context from SC | nonce=${nonce}, to=${to}`);
    const { chainId } = await sourceProvider.getNetwork();

    const txObj = {
      to,
      data,
      nonce: Number(nonce),
      blockNumber: event.blockNumber,
      chainId
    };
    console.log("üì¨ Relaying to:", to);
    console.log("üì¨ Should match TargetReceiver:", require("./deployments/destinationChain/TargetReceiver.json").address);


    const proof = await generateProof(txObj, "SC2RC");

    await updateLatencies(RELAY_CHAINS);
    await updateResourceInfo(RELAY_CHAINS);
    await updatePerformanceMetrics(RELAY_CHAINS, calculateSuccessRate);
    await updateAdaptiveProperties(RELAY_CHAINS);

    RELAY_CHAINS.forEach(rc => rc.weight = computeWeight(rc));

    const selectedRC = selectRelay_HybridAdaptive(
      RELAY_CHAINS,
      "General",
      {
        General: {
          requiredTypes: ["General"],
          minSecurityLevel: "Low",
          minProcessingSpeed: "Slow",
          maxCostTier: "Standard",
          requiredTokens: ["ETH"],
          minGasLimit: 100000,
          priority: "Low"
        }
      },
      calculateSuccessRate
    );

    if (!selectedRC) {
      console.warn("‚ùå No suitable relay available");
      return;
    }

    const relaySigner = new ethers.Wallet(process.env.PRIVATE_KEY, selectedRC.provider);
    const selectedRegistryAddress = registryAddresses[selectedRC.name];
    const registry = new ethers.Contract(selectedRegistryAddress, RelayRegistryABI, relaySigner);

    try {
      const tx = await registry.relayFromSource(to, data, proof.proofHash);
      await tx.wait();
      console.log(`‚úÖ Relayed ctx[${nonce}] to ${selectedRC.name}: tx=${tx.hash}`);
    } catch (e) {
      console.error(`üî• Relay failed to ${selectedRC.name}:`, e.message);
    }
  });
}

main();

```

### script\prover.js
```js
const { ethers } = require("ethers");

// Gi·∫£ l·∫≠p ƒë·ªô tr·ªÖ t·∫°o proof (ms)
const DEFAULT_DELAY_MS = 300;

function sleep(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}

/**
 * Sinh proof gi·∫£ l·∫≠p t·ª´ giao d·ªãch
 * @param {Object} transaction - Giao d·ªãch t·ª´ SC ho·∫∑c RC
 * @param {String} type - 'SC2RC' ho·∫∑c 'RC2DC'
 * @returns {Object} - B·∫±ng ch·ª©ng g·ªìm hash, timestamp v√† th·ªùi gian x·ª≠ l√Ω
 */
async function generateProof(transaction, type = 'SC2RC') {
  const start = Date.now();

  // Gi·∫£ l·∫≠p ƒë·ªô tr·ªÖ t·∫°o proof
  await sleep(DEFAULT_DELAY_MS);

  const proofHash = ethers.keccak256(ethers.getBytes(transaction.data));

  const proof = {
    proofHash,
    createdAt: new Date().toISOString(),
    elapsedMs: Date.now() - start,
    proofType: type
  };

  return proof;
}

module.exports = {
  generateProof
};

```

### script\sendCtx.js
```js
// sendCtx.js
require("dotenv").config();
const { ethers } = require("hardhat");

async function main() {
  const [signer] = await ethers.getSigners();
  const SourceApp = await ethers.getContractFactory("SourceApp");

  // ƒê·ªçc ƒë·ªãa ch·ªâ contract t·ª´ deploy
  const deployed = require("./deployments/sourceChain/SourceApp.json");
  const sourceApp = await SourceApp.attach(deployed.address);

  const dummyTarget = require("./deployments/destinationChain/TargetReceiver.json").address;


  const payload = ethers.encodeBytes32String("cross-chain-ping");

  const tx = await sourceApp.sendContext(dummyTarget, payload);
  console.log("‚è≥ Sending ctx...");
  await tx.wait();
  console.log("‚úÖ ctx sent: ", tx.hash);
}

main().catch((err) => {
  console.error(err);
  process.exit(1);
});

```

### script\simulation.js
```js
const { ethers } = require("hardhat");
const registryAddress = require('../registry-address.json').address;
const {
  selectRelay_WeightedRoundRobin,
  selectRelay_WLC,
  selectRelay_ResourceBased,
  selectRelay_HybridAdaptive,
  updateLatencies,
  calculateSuccessRate,
  updateResourceInfo,
  updatePerformanceMetrics,
  updateAdaptiveProperties, 
  trackTransactionResult,
  computeWeight
} = require('../relay-algorithms');



// const RELAY_CHAINS = [
//   { name: 'RelayChain1', url: 'http://127.0.0.1:8545', load: 0, latency: 0, healthy: true, provider: null, successCount: 0 },
//   { name: 'RelayChain2', url: 'http://127.0.0.1:8546', load: 0, latency: 0, healthy: true, provider: null, successCount: 0 },
//   { name: 'RelayChain3', url: 'http://127.0.0.1:8547', load: 0, latency: 0, healthy: true, provider: null, successCount: 0 },
// ];

const RELAY_CHAINS = [
  { 
    name: 'RelayChain1', 
    url: 'http://127.0.0.1:8545', 
    load: 0, 
    latency: 0, 
    healthy: true, 
    provider: null, 
    successCount: 0,
    totalRequests: 0,
    gasPrice: 0,
    blockTime: 0,
    networkCongestion: 0,
    historicalLatency: [],
    maxLatency: 0,
    minLatency: Infinity,
    
    // Adaptive capabilities - s·∫Ω ƒë∆∞·ª£c t√≠nh to√°n ƒë·ªông
    capabilities: {
      transactionTypes: ['DeFi', 'NFT', 'Gaming', 'General'],
      chainTypes: ['EVM', 'Layer2'],
      supportedTokens: ['ETH', 'USDC', 'USDT', 'DAI'],
      // C√°c thu·ªôc t√≠nh adaptive - s·∫Ω ƒë∆∞·ª£c t√≠nh to√°n
      securityLevel: 'Medium', // S·∫Ω ƒë∆∞·ª£c t√≠nh to√°n
      processingSpeed: 'Normal', // S·∫Ω ƒë∆∞·ª£c t√≠nh to√°n
      costTier: 'Standard', // S·∫Ω ƒë∆∞·ª£c t√≠nh to√°n
      maxGasLimit: 20000000, // S·∫Ω ƒë∆∞·ª£c t√≠nh to√°n
    },
    
    // Metrics ƒë·ªÉ t√≠nh to√°n adaptive properties
    adaptiveMetrics: {
      // Security metrics
      failureRate: 0,
      consecutiveFailures: 0,
      lastFailureTime: 0,
      securityScore: 1.0,
      
      // Performance metrics
      avgLatency: 0,
      latencyVariance: 0,
      throughput: 0,
      performanceScore: 1.0,
      
      // Cost metrics
      avgGasPrice: 0,
      gasPriceTrend: 0,
      costEfficiency: 1.0,
      costScore: 1.0,
      
      // Capacity metrics
      currentGasUsage: 0,
      maxObservedGas: 0,
      capacityUtilization: 0,
      capacityScore: 1.0,
      
      // Historical data
      latencyHistory: [],
      gasPriceHistory: [],
      failureHistory: [],
      successHistory: []
    },
    
    performance: {
      avgProcessingTime: 0,
      reliabilityScore: 1.0,
      costEfficiency: 1.0
    }
  },
  { 
    name: 'RelayChain2', 
    url: 'http://127.0.0.1:8546', 
    load: 0, 
    latency: 0, 
    healthy: true, 
    provider: null, 
    successCount: 0,
    totalRequests: 0,
    gasPrice: 0,
    blockTime: 0,
    networkCongestion: 0,
    historicalLatency: [],
    maxLatency: 0,
    minLatency: Infinity,
    
    // Adaptive capabilities - s·∫Ω ƒë∆∞·ª£c t√≠nh to√°n ƒë·ªông
    capabilities: {
      transactionTypes: ['DeFi', 'NFT', 'Gaming', 'General'],
      chainTypes: ['EVM', 'Layer2'],
      supportedTokens: ['ETH', 'USDC', 'USDT', 'DAI'],
      // C√°c thu·ªôc t√≠nh adaptive - s·∫Ω ƒë∆∞·ª£c t√≠nh to√°n
      securityLevel: 'Medium', // S·∫Ω ƒë∆∞·ª£c t√≠nh to√°n
      processingSpeed: 'Normal', // S·∫Ω ƒë∆∞·ª£c t√≠nh to√°n
      costTier: 'Standard', // S·∫Ω ƒë∆∞·ª£c t√≠nh to√°n
      maxGasLimit: 20000000, // S·∫Ω ƒë∆∞·ª£c t√≠nh to√°n
    },
    
    // Metrics ƒë·ªÉ t√≠nh to√°n adaptive properties
    adaptiveMetrics: {
      // Security metrics
      failureRate: 0,
      consecutiveFailures: 0,
      lastFailureTime: 0,
      securityScore: 1.0,
      
      // Performance metrics
      avgLatency: 0,
      latencyVariance: 0,
      throughput: 0,
      performanceScore: 1.0,
      
      // Cost metrics
      avgGasPrice: 0,
      gasPriceTrend: 0,
      costEfficiency: 1.0,
      costScore: 1.0,
      
      // Capacity metrics
      currentGasUsage: 0,
      maxObservedGas: 0,
      capacityUtilization: 0,
      capacityScore: 1.0,
      
      // Historical data
      latencyHistory: [],
      gasPriceHistory: [],
      failureHistory: [],
      successHistory: []
    },
    
    performance: {
      avgProcessingTime: 0,
      reliabilityScore: 1.0,
      costEfficiency: 1.0
    }
  },
  { 
    name: 'RelayChain3', 
    url: 'http://127.0.0.1:8547', 
    load: 0, 
    latency: 0, 
    healthy: true, 
    provider: null, 
    successCount: 0,
    totalRequests: 0,
    gasPrice: 0,
    blockTime: 0,
    networkCongestion: 0,
    historicalLatency: [],
    maxLatency: 0,
    minLatency: Infinity,
    
    // Adaptive capabilities - s·∫Ω ƒë∆∞·ª£c t√≠nh to√°n ƒë·ªông
    capabilities: {
      transactionTypes: ['DeFi', 'NFT', 'Gaming', 'General'],
      chainTypes: ['EVM', 'Layer2'],
      supportedTokens: ['ETH', 'USDC', 'USDT', 'DAI'],
      // C√°c thu·ªôc t√≠nh adaptive - s·∫Ω ƒë∆∞·ª£c t√≠nh to√°n
      securityLevel: 'Medium', // S·∫Ω ƒë∆∞·ª£c t√≠nh to√°n
      processingSpeed: 'Normal', // S·∫Ω ƒë∆∞·ª£c t√≠nh to√°n
      costTier: 'Standard', // S·∫Ω ƒë∆∞·ª£c t√≠nh to√°n
      maxGasLimit: 20000000, // S·∫Ω ƒë∆∞·ª£c t√≠nh to√°n
    },
    
    // Metrics ƒë·ªÉ t√≠nh to√°n adaptive properties
    adaptiveMetrics: {
      // Security metrics
      failureRate: 0,
      consecutiveFailures: 0,
      lastFailureTime: 0,
      securityScore: 1.0,
      
      // Performance metrics
      avgLatency: 0,
      latencyVariance: 0,
      throughput: 0,
      performanceScore: 1.0,
      
      // Cost metrics
      avgGasPrice: 0,
      gasPriceTrend: 0,
      costEfficiency: 1.0,
      costScore: 1.0,
      
      // Capacity metrics
      currentGasUsage: 0,
      maxObservedGas: 0,
      capacityUtilization: 0,
      capacityScore: 1.0,
      
      // Historical data
      latencyHistory: [],
      gasPriceHistory: [],
      failureHistory: [],
      successHistory: []
    },
    
    performance: {
      avgProcessingTime: 0,
      reliabilityScore: 1.0,
      costEfficiency: 1.0
    }
  }
];


// üéØ Transaction Requirements - c√≥ th·ªÉ thay ƒë·ªïi theo t·ª´ng transaction
const TRANSACTION_REQUIREMENTS = {
  // Requirements cho DeFi transaction
  DeFi: {
    requiredTypes: ['DeFi'],
    minSecurityLevel: 'Medium',
    minProcessingSpeed: 'Normal',
    maxCostTier: 'Premium',
    requiredTokens: ['ETH', 'USDC', 'USDT'],
    minGasLimit: 500000,
    priority: 'High'
  },
  
  // Requirements cho NFT transaction
  NFT: {
    requiredTypes: ['NFT'],
    minSecurityLevel: 'Medium',
    minProcessingSpeed: 'Normal',
    maxCostTier: 'Standard',
    requiredTokens: ['ETH'],
    minGasLimit: 300000,
    priority: 'Medium'
  },
  
  // Requirements cho Gaming transaction
  Gaming: {
    requiredTypes: ['Gaming'],
    minSecurityLevel: 'Low',
    minProcessingSpeed: 'Normal',
    maxCostTier: 'Economy',
    requiredTokens: ['ETH'],
    minGasLimit: 200000,
    priority: 'Low'
  },
  
  // Requirements cho General transaction
  General: {
    requiredTypes: ['General'],
    minSecurityLevel: 'Low',
    minProcessingSpeed: 'Slow',
    maxCostTier: 'Economy',
    requiredTokens: ['ETH'],
    minGasLimit: 100000,
    priority: 'Low'
  }
};

async function main() {
  console.log("üöÄ Starting MRC Simulation ...");
  let fallbackCount = 0

  for (const chain of RELAY_CHAINS) {
    try {
      chain.provider = new ethers.JsonRpcProvider(chain.url);
      await chain.provider.getNetwork();
      console.log(`‚úÖ Connected to ${chain.name}`);
    } catch (e) {
      console.error(`‚ùå Could not connect to ${chain.name}: ${e.message}`);
      chain.healthy = false;
    }
  }

  const healthyRelays = RELAY_CHAINS.filter(r => r.healthy);
  if (healthyRelays.length === 0) {
    console.error("‚ùå No healthy relay chains available. Exiting.");
    return;
  }

  const mainProvider = healthyRelays[0].provider;
  const registry = await ethers.getContractAt("RelayRegistry", registryAddress, await mainProvider.getSigner());
  console.log(`\nüîó Connected to RelayRegistry at ${registryAddress}`);

  const SOURCE_CHAIN_ID = "SourceChain-A";
  const NUM_TRANSACTIONS = 20;
  const useWLC = false; 
  const useResourceBased = false;
  const useHybridAdaptive = true;
  const transactionTypes = ['DeFi', 'NFT', 'Gaming', 'General'];

  console.log(`\nüîÑ Simulating ${NUM_TRANSACTIONS} cross-chain transactions using ${useWLC ? 'WLC' : useResourceBased ? 'Resource-Based' : useHybridAdaptive ? 'Hybrid Adaptive' : 'Round Robin'}...\n`);

  for (let i = 1; i <= NUM_TRANSACTIONS; i++) {
    console.log(`--- Transaction #${i} ---`);

    // Ch·ªçn ng·∫´u nhi√™n transaction type
    const transactionType = transactionTypes[Math.floor(Math.random() * transactionTypes.length)];
    console.log(`üìã Transaction Type: ${transactionType}`);

    await updateLatencies(RELAY_CHAINS);
    await updateResourceInfo(RELAY_CHAINS);
    await updatePerformanceMetrics(RELAY_CHAINS, calculateSuccessRate);
    await updateAdaptiveProperties(RELAY_CHAINS); 

        
    for (const chain of RELAY_CHAINS) {
      const weight = computeWeight(chain);
      console.log(`‚öñÔ∏è  ${chain.name} - Computed Weight: ${weight}`);
    }

    let selectedRelay;
    try {
      if (useHybridAdaptive) {
        selectedRelay = selectRelay_HybridAdaptive(RELAY_CHAINS, transactionType, TRANSACTION_REQUIREMENTS, calculateSuccessRate);
  
        if (!selectedRelay) {
          console.warn(`‚ö†Ô∏è No eligible relays found for ${transactionType}, falling back to WLC...`);
          selectedRelay = selectRelay_WLC(RELAY_CHAINS);
          fallbackCount++;
        }
      } else if (useResourceBased) {
        selectedRelay = selectRelay_ResourceBased(RELAY_CHAINS);
      } else if (useWLC) {
        selectedRelay = selectRelay_WLC(RELAY_CHAINS);
      } else {
        selectedRelay = selectRelay_WeightedRoundRobin(RELAY_CHAINS);
      }      
    } catch (e) {
      console.error("‚ùå No suitable relay at this time.");
      continue;
    }

    console.log(`‚öñÔ∏è  Selected: ${selectedRelay.name} | Load: ${selectedRelay.load} | Latency: ${selectedRelay.latency}ms`);
    console.log(`   Adaptive Properties: ${selectedRelay.capabilities.securityLevel}/${selectedRelay.capabilities.processingSpeed}/${selectedRelay.capabilities.costTier}`);


    try {
      selectedRelay.load++; // tƒÉng khi b·∫Øt ƒë·∫ßu
      selectedRelay.totalRequests++; 

      const signer = await selectedRelay.provider.getSigner();
      const tx = await signer.sendTransaction({
        to: signer.address,
        value: ethers.parseEther("0.001")
      });

      await tx.wait();
      selectedRelay.successCount++;

      // Track successful transaction
      trackTransactionResult(selectedRelay, true, 21000); // ∆Ø·ªõc t√≠nh gas used

      console.log(`üì¨ Tx #${i} sent to ${selectedRelay.name}: ${tx.hash}`);
    } catch (e) {
      console.error(`üî• Error with ${selectedRelay.name}: ${e.message}`);
      selectedRelay.healthy = false;
      // Track failed transaction
      trackTransactionResult(selectedRelay, false);
    } finally {
      selectedRelay.load--; // gi·∫£m khi ho√†n t·∫•t
    }
    await new Promise(resolve => setTimeout(resolve, 500));
  }

  console.log("\n‚úÖ SIMULATION COMPLETE");
  if (useHybridAdaptive)
    console.log(`üö® Total Fallbacks to WLC: ${fallbackCount} / ${NUM_TRANSACTIONS}`);
  console.log("üìä Final Relay Stats:");
  RELAY_CHAINS.forEach(chain => {
    console.log(`  - ${chain.name}: Success=${chain.successCount} tx | Latency=${chain.latency}ms | Healthy=${chain.healthy}`);
  });
}

main().catch((error) => {
  console.error(error);
  process.exitCode = 1;
});

```

### test\Lock.js
```js
const {
  time,
  loadFixture,
} = require("@nomicfoundation/hardhat-toolbox/network-helpers");
const { anyValue } = require("@nomicfoundation/hardhat-chai-matchers/withArgs");
const { expect } = require("chai");

describe("Lock", function () {
  // We define a fixture to reuse the same setup in every test.
  // We use loadFixture to run this setup once, snapshot that state,
  // and reset Hardhat Network to that snapshot in every test.
  async function deployOneYearLockFixture() {
    const ONE_YEAR_IN_SECS = 365 * 24 * 60 * 60;
    const ONE_GWEI = 1_000_000_000;

    const lockedAmount = ONE_GWEI;
    const unlockTime = (await time.latest()) + ONE_YEAR_IN_SECS;

    // Contracts are deployed using the first signer/account by default
    const [owner, otherAccount] = await ethers.getSigners();

    const Lock = await ethers.getContractFactory("Lock");
    const lock = await Lock.deploy(unlockTime, { value: lockedAmount });

    return { lock, unlockTime, lockedAmount, owner, otherAccount };
  }

  describe("Deployment", function () {
    it("Should set the right unlockTime", async function () {
      const { lock, unlockTime } = await loadFixture(deployOneYearLockFixture);

      expect(await lock.unlockTime()).to.equal(unlockTime);
    });

    it("Should set the right owner", async function () {
      const { lock, owner } = await loadFixture(deployOneYearLockFixture);

      expect(await lock.owner()).to.equal(owner.address);
    });

    it("Should receive and store the funds to lock", async function () {
      const { lock, lockedAmount } = await loadFixture(
        deployOneYearLockFixture
      );

      expect(await ethers.provider.getBalance(lock.target)).to.equal(
        lockedAmount
      );
    });

    it("Should fail if the unlockTime is not in the future", async function () {
      // We don't use the fixture here because we want a different deployment
      const latestTime = await time.latest();
      const Lock = await ethers.getContractFactory("Lock");
      await expect(Lock.deploy(latestTime, { value: 1 })).to.be.revertedWith(
        "Unlock time should be in the future"
      );
    });
  });

  describe("Withdrawals", function () {
    describe("Validations", function () {
      it("Should revert with the right error if called too soon", async function () {
        const { lock } = await loadFixture(deployOneYearLockFixture);

        await expect(lock.withdraw()).to.be.revertedWith(
          "You can't withdraw yet"
        );
      });

      it("Should revert with the right error if called from another account", async function () {
        const { lock, unlockTime, otherAccount } = await loadFixture(
          deployOneYearLockFixture
        );

        // We can increase the time in Hardhat Network
        await time.increaseTo(unlockTime);

        // We use lock.connect() to send a transaction from another account
        await expect(lock.connect(otherAccount).withdraw()).to.be.revertedWith(
          "You aren't the owner"
        );
      });

      it("Shouldn't fail if the unlockTime has arrived and the owner calls it", async function () {
        const { lock, unlockTime } = await loadFixture(
          deployOneYearLockFixture
        );

        // Transactions are sent using the first signer by default
        await time.increaseTo(unlockTime);

        await expect(lock.withdraw()).not.to.be.reverted;
      });
    });

    describe("Events", function () {
      it("Should emit an event on withdrawals", async function () {
        const { lock, unlockTime, lockedAmount } = await loadFixture(
          deployOneYearLockFixture
        );

        await time.increaseTo(unlockTime);

        await expect(lock.withdraw())
          .to.emit(lock, "Withdrawal")
          .withArgs(lockedAmount, anyValue); // We accept any value as `when` arg
      });
    });

    describe("Transfers", function () {
      it("Should transfer the funds to the owner", async function () {
        const { lock, unlockTime, lockedAmount, owner } = await loadFixture(
          deployOneYearLockFixture
        );

        await time.increaseTo(unlockTime);

        await expect(lock.withdraw()).to.changeEtherBalances(
          [owner, lock],
          [lockedAmount, -lockedAmount]
        );
      });
    });
  });
});

```
